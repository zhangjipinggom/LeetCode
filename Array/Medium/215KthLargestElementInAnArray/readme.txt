1. 想到的第一种解法很直观： 建立一个list用来装排好序的nums,再取出第K-1个元素即可
这种排序方法借鉴了414题的解法2的扩展
这种排序方法的缺点是时间复杂度太高（O(n**3)）  # 可能不是，需要学习计算复杂度的问题


2. 第二个function是对第一个function的改进，改进了改变list的方式，在submit时能节约1000秒
（O(N**2)）
无论如何，相当于从自己很笨的方法先实现了排序再来做的


3. 用priority queue(PQ, 一种已有的数据结构， 优先队列， first in， largest out)
利用PQ来存储K个值，从最大到第K大的值，这K个值从小到大排列，首个元素就是我们要求的值
基于二叉树，但是这个二叉树要满足子节点大于等于父节点
# 其实这种方法反倒是最简单也最快的

4. 用快速排序来做
最速排序的做法，选一个数作为pivot（中心点），找这个中心点的正确位置，使满足中心点左边的数都比它小或相等，右边的数都比它大，
将原本的数划分为两部分。再在两个部分各选pivot同样操作，直到所有的数都被选过(这样所有的数都找到了正确的位置)
也就是说，快速排序由两大部分组成：取中心点找其位置，划分子序列（pivot， partition），重复。
快速排序的最好的情况（pivot左右两边的数的个数差不多），时间复杂度为O(NlogN)
最坏的情况，都在pivot最左边或者最右边，时间复杂度为O(N**2)
# 系统中的sorted是怎么实现的呢？这么快

在真正写代码实现快速排序的时候有非常多的坑：包括想用pop,insert来做，结果pop和insert后nums的值改变，index不再是自己
想要的
实现的时候的关键点，设置一个标记比pivot大和比pivot小的分界点，最后把pivot插入这个分界点（用比它大的和它交换）




总结：这里学到了几个比较重要的点：
1. 通过新建一个list来装从大到小排好序的list,None的初始化
2. 通过PQ求解，新建一个长度为k的list来装K个最大的从小到大
3. 通过快速排序的思想，如果pivot现在所在的位置恰好是K，说明找到了，可以不用新建list,直接修改原来的list.

学会了快速排序，pq